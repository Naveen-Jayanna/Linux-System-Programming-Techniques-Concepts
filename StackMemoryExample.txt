Here is a sample demonstration steps exercising stack memory concepts in 
procedure call and return we discussed :

Consider a code snippet below :


extern int add(int a, int b);
int
add(int a, int b){
    int c = a + b;
    return c;
}

int
main(int argc, char **argv){
    int a = 45;
    int b = 43;
    int c = add(a,b);
    return 0;
}

Now let see, how main invoked add() and then add() returns the result back to caller step by step.
This is assembly code below which will be (approx) generated by compiler corresponding to above C code. 
I understand you may not know assembly, but below code is simple enough to go through it even if you dont know assembly.
Advise : PLs draw a stack memory diagram along side to understand the below code.

In below example, [] is equivalent to *p i.e. access value at address p.

1. main : push b 		<< push arg b into stack memory
2. main : push a		<< push arg a into stack memory
3. main : push eip		<< push eip value (= address of next instruction to be executed when callee returns) in stack memory 
4. main : call add      << eip is updated to point to first instruction in add(), `call` is a system call provided by linux to transfer control 
From hereon, control transfer to add()
5. add : push ebp		<< push base pointer register value in stack memory, now we can update ebp register since its old value is saved
6. add : mov ebp, esp   << push current stack pointer address into ebp register. Note : Step 5 and 6 are always performed for all function invocations. 
7. add : sub esp , 4 	<< sub stands for subtract, Now, callee has 'c' as local variable which is of 4 bytes and is used to store results, Calee lower down the esp by 4 more bytes to create additional room in stack memory for local variable c
8. add : mov ebx, 0     << take additional variable ebx to perform calculation, initialize it to zero
9. add : add ebx, [ebp + 8]  << ebx += a , here value of a is 8 bytes away towards higher address in stack memory from base address (= address stored in ebp register at this time). We discussed, all local variables and arguments are accessed relative to ebp. Assembly code do not contain variable names like a,b,c which you defined in your high-level C program.
10. add:  add ebx, [ebp + 12] << ebx += b , here value of b is 12 bytes away towards higher address in stack memory from base address 
11. add : mov [esp], ebx      << Store the result in stack memory 
12. add : mov eax, [esp]      << store the return value in eax register 
13. add : add esp, 4		  << pop the memory for local variable c, this is done by adding 4B to current value of esp.
14. add : mov ebp, [esp]	  << restore base pointer register to point to caller's base address  
15. add : pop ebp             << pop out ebp from stack memory , note : pop operations implicitly update esp as per the size of argument popped.
16: add : ret  <<  this pops out the instruction pointer which was saved in stack memory, update eip = popped instruction address, control transfers to caller now
so basically, above ret statement performs below two operations.
    main : mov eip, [esp]
    main : pop eip 
18. main : pop b    << Caller pops out the arguments it pushed into stack memory when callee returns in the reverse order
19. main : pop a    << Caller pops out the arguments it pushed into stack memory when callee returns in the reverse order
<stack frame of add() is completely freed now ... >


Above same steps explained in Layman terms :
When Caller Calls the Calee 
1. Caller pushed Callee's arguments in reverse order in stack memory
2. Caller Saves Instruction pointer in stack memory 
3. Caller transfers control to callee
4. Callee pushed ebp into stack memory, and update ebp with its own base address
5. if Callee has its own local variables, it pushes them too into stack memory as they come into scope, when local variable goes out of scope, they are popped out
6. Callee performs computation and store results in stack memory created for local variables storage in step 5.
7. When callee terminates, all its local variables goes out of scope - so all local variables are popped out in reverse order in which they were pushed.
8. saved ebp value in stack memory pops out, and ebp register is updated with this popped out value 
9. saved eip value in stack memory pops out, and eip register is updated with this popped out value
10. control transfers to Caller
11. Caller pops out all arguments it had pushed in step 1

Note that, all push pop logic is "statically generated by compiler at compile time".
For example, if caller needs to push arg X, Y, Z prior to call function F, then corresponding pop calls are also inserted into assembly code right after function F.

PUSH X
PUSH Y
PUSH Z
call F
POP Z
POP Y
POP X

Similarly, when callee is in execution, as soon as compiler sees a new local variable V coming into scope, PUSH V code is generated , and POP V code is generated when variable goes out of scope. All this code genration happens at compile time, not at run time. 
Here is an assembly code which implements exact above logic, pls go through it once, focus on stack memory part only if you don't know assembly. The program is heavely commented throughout. You need to install nasm (the assembler) to run this program. To install nasm, run-  sudo apt-get install nasm
Download both the files. How to run steps are present at top of 'asm' file.
https://github.com/sachinites/NASMAssembly/blob/master/proc_to_add_2_numbers_v2.asm
https://github.com/sachinites/NASMAssembly/blob/master/scanf.c